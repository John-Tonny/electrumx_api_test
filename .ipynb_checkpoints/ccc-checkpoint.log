{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "ename": "SyntaxError",
     "evalue": "invalid syntax (<ipython-input-1-59ba8bb7c763>, line 1)",
     "output_type": "error",
     "traceback": [
      "\u001b[0;36m  File \u001b[0;32m\"<ipython-input-1-59ba8bb7c763>\"\u001b[0;36m, line \u001b[0;32m1\u001b[0m\n\u001b[0;31m    import rpcd-web\u001b[0m\n\u001b[0m               ^\u001b[0m\n\u001b[0;31mSyntaxError\u001b[0m\u001b[0;31m:\u001b[0m invalid syntax\n"
     ]
    }
   ],
   "source": [
    "import rpcd-web"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "import myssl"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "ename": "SyntaxError",
     "evalue": "Missing parentheses in call to 'print'. Did you mean print(myssl)? (<ipython-input-3-9baefd533633>, line 1)",
     "output_type": "error",
     "traceback": [
      "\u001b[0;36m  File \u001b[0;32m\"<ipython-input-3-9baefd533633>\"\u001b[0;36m, line \u001b[0;32m1\u001b[0m\n\u001b[0;31m    print myssl\u001b[0m\n\u001b[0m              ^\u001b[0m\n\u001b[0;31mSyntaxError\u001b[0m\u001b[0;31m:\u001b[0m Missing parentheses in call to 'print'. Did you mean print(myssl)?\n"
     ]
    }
   ],
   "source": [
    "print myssl"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# %load myssl.py\n",
    "#!/usr/bin/env python\n",
    "#\n",
    "# Electrum - lightweight Bitcoin client\n",
    "# Copyright (C) 2011 thomasv@gitorious\n",
    "#\n",
    "# Permission is hereby granted, free of charge, to any person\n",
    "# obtaining a copy of this software and associated documentation files\n",
    "# (the \"Software\"), to deal in the Software without restriction,\n",
    "# including without limitation the rights to use, copy, modify, merge,\n",
    "# publish, distribute, sublicense, and/or sell copies of the Software,\n",
    "# and to permit persons to whom the Software is furnished to do so,\n",
    "# subject to the following conditions:\n",
    "#\n",
    "# The above copyright notice and this permission notice shall be\n",
    "# included in all copies or substantial portions of the Software.\n",
    "#\n",
    "# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n",
    "# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n",
    "# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n",
    "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n",
    "# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n",
    "# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n",
    "# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n",
    "# SOFTWARE.\n",
    "import os\n",
    "import re\n",
    "import socket\n",
    "import ssl\n",
    "import sys\n",
    "import threading\n",
    "import time\n",
    "import traceback\n",
    "import json\n",
    "import requests\n",
    "\n",
    "\n",
    "\n",
    "#ca_path = requests.certs.where()\n",
    "ca_path = '/home/john/myapi/cacert.pem'\n",
    "\n",
    "import util\n",
    "import x509\n",
    "import pem\n",
    "#from electrum_dash.version import ELECTRUM_VERSION, PROTOCOL_VERSION\n",
    "\n",
    "def parse_json(message):\n",
    "    # TODO: check \\r\\n pattern\n",
    "    n = message.find(b'\\n')\n",
    "    if n==-1:\n",
    "        return None, message\n",
    "    try:\n",
    "        j = json.loads(message[0:n].decode('utf8'))\n",
    "    except:\n",
    "        j = None\n",
    "    return j, message[n+1:]\n",
    "\n",
    "\n",
    "class SocketPipe:\n",
    "    def __init__(self, socket):\n",
    "        self.socket = socket\n",
    "        self.message = b''\n",
    "        self.set_timeout(0.1)\n",
    "        self.recv_time = time.time()\n",
    "        self.msg = ''\n",
    "        \n",
    "    def addMsg(self,*args):\n",
    "        self.msg=args\n",
    "\n",
    "    def set_timeout(self, t):\n",
    "        self.socket.settimeout(t)\n",
    "\n",
    "    def idle_time(self):\n",
    "        return time.time() - self.recv_time\n",
    "    \n",
    "    def send_requests(self):\n",
    "        '''Sends queued requests.  Returns False on failure.'''\n",
    "        make_dict = lambda m, p, i: {'method': m, 'params': p, 'id': i}\n",
    "        wire_requests = []\n",
    "        wire_requests.append(self.msg)\n",
    "        try:\n",
    "            self.send_all([make_dict(*r) for r in wire_requests])\n",
    "        except BaseException as e:\n",
    "            #self.print_error(\"pipe send error:\", e)\n",
    "            return False\n",
    "        return True\n",
    "    \n",
    "    def get(self):\n",
    "        while True:\n",
    "            response, self.message = parse_json(self.message)\n",
    "            if response is not None:\n",
    "                return response\n",
    "            try:\n",
    "                data = self.socket.recv(1024)\n",
    "            except socket.timeout:\n",
    "                raise timeout\n",
    "            except ssl.SSLError:\n",
    "                raise timeout\n",
    "            except socket.error as err:\n",
    "                if err.errno == 60:\n",
    "                    raise timeout\n",
    "                elif err.errno in [11, 35, 10035]:\n",
    "                    print_error(\"socket errno %d (resource temporarily unavailable)\"% err.errno)\n",
    "                    time.sleep(0.2)\n",
    "                    raise timeout\n",
    "                else:\n",
    "                    print_error(\"pipe: socket error\", err)\n",
    "                    data = b''\n",
    "            except:\n",
    "                traceback.print_exc(file=sys.stderr)\n",
    "                data = b''\n",
    "\n",
    "            if not data:  # Connection closed remotely\n",
    "                return None\n",
    "            self.message += data\n",
    "            self.recv_time = time.time()\n",
    "        return self.message\n",
    "\n",
    "    def send(self, request):\n",
    "        out = json.dumps(request) + '\\n'\n",
    "        out = out.encode('utf8')\n",
    "        self._send(out)\n",
    "\n",
    "    def send_all(self, requests):\n",
    "        out = b''.join(map(lambda x: (json.dumps(x) + '\\n').encode('utf8'), requests))\n",
    "        self._send(out)\n",
    "\n",
    "    def _send(self, out):\n",
    "        while out:\n",
    "            try:\n",
    "                sent = self.socket.send(out)\n",
    "                out = out[sent:]\n",
    "            except ssl.SSLError as e:\n",
    "                print_error(\"SSLError:\", e)\n",
    "                time.sleep(0.1)\n",
    "                continue\n",
    "\n",
    "class TcpConnection(util.PrintError):\n",
    "    verbosity_filter = 'i'\n",
    "\n",
    "    def __init__(self,config_path):\n",
    "        self.config_path = config_path\n",
    "        self.host='192.168.140.129'\n",
    "        self.port=50002\n",
    "        self.host = str(self.host)\n",
    "        self.port = int(self.port)\n",
    "        self.use_ssl = True\n",
    "        self.config_path = config_path\n",
    "\n",
    "    def get_simple_socket(self):\n",
    "        try:\n",
    "            ll = socket.getaddrinfo(self.host, self.port, socket.AF_UNSPEC, socket.SOCK_STREAM)\n",
    "        except socket.gaierror:\n",
    "            self.print_error(\"cannot resolve hostname\")\n",
    "            return\n",
    "        e = None\n",
    "        for res in ll:\n",
    "            try:\n",
    "                s = socket.socket(res[0], socket.SOCK_STREAM)\n",
    "                s.settimeout(10)\n",
    "                s.connect(res[4])\n",
    "                s.settimeout(2)\n",
    "                s.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n",
    "                return s\n",
    "            except BaseException as _e:\n",
    "                e = _e\n",
    "                continue\n",
    "        else:\n",
    "            self.print_error(\"failed to connect\", str(e))\n",
    "            pass\n",
    "\n",
    "    @staticmethod\n",
    "    def get_ssl_context(cert_reqs, ca_certs):\n",
    "        context = ssl.create_default_context(purpose=ssl.Purpose.SERVER_AUTH, cafile=ca_certs)\n",
    "        context.check_hostname = False\n",
    "        context.verify_mode = cert_reqs\n",
    "\n",
    "        context.options |= ssl.OP_NO_SSLv2\n",
    "        context.options |= ssl.OP_NO_SSLv3\n",
    "        context.options |= ssl.OP_NO_TLSv1\n",
    "\n",
    "        return context\n",
    "\n",
    "    def get_socket(self):\n",
    "        if self.use_ssl:\n",
    "            cert_path = os.path.join(self.config_path, 'certs', self.host)\n",
    "            if not os.path.exists(cert_path):\n",
    "                is_new = True\n",
    "                s = self.get_simple_socket()\n",
    "                if s is None:\n",
    "                    return\n",
    "                # try with CA first\n",
    "                try:\n",
    "                    context = self.get_ssl_context(cert_reqs=ssl.CERT_REQUIRED, ca_certs=ca_path)\n",
    "                    s = context.wrap_socket(s, do_handshake_on_connect=True)\n",
    "                except ssl.SSLError as e:\n",
    "                    self.print_error(e)\n",
    "                except:\n",
    "                    return\n",
    "                else:\n",
    "                    try:\n",
    "                        peer_cert = s.getpeercert()\n",
    "                    except OSError:\n",
    "                        return\n",
    "                    if self.check_host_name(peer_cert, self.host):\n",
    "                        self.print_error(\"SSL certificate signed by CA\")\n",
    "                        return s\n",
    "                # get server certificate.\n",
    "                # Do not use ssl.get_server_certificate because it does not work with proxy\n",
    "                s = self.get_simple_socket()\n",
    "                if s is None:\n",
    "                    return\n",
    "                try:\n",
    "                    context = self.get_ssl_context(cert_reqs=ssl.CERT_NONE, ca_certs=None)\n",
    "                    s = context.wrap_socket(s)\n",
    "                except ssl.SSLError as e:\n",
    "                    self.print_error(\"SSL error retrieving SSL certificate:\", e)\n",
    "                    return\n",
    "                except:\n",
    "                    return\n",
    "\n",
    "                try:\n",
    "                    dercert = s.getpeercert(True)\n",
    "                except OSError:\n",
    "                    return\n",
    "                s.close()\n",
    "                cert = ssl.DER_cert_to_PEM_cert(dercert)\n",
    "                # workaround android bug\n",
    "                cert = re.sub(\"([^\\n])-----END CERTIFICATE-----\",\"\\\\1\\n-----END CERTIFICATE-----\",cert)\n",
    "                temporary_path = cert_path + '.temp'\n",
    "                util.assert_datadir_available(self.config_path)\n",
    "                with open(temporary_path, \"w\", encoding='utf-8') as f:\n",
    "                    f.write(cert)\n",
    "                    f.flush()\n",
    "                    os.fsync(f.fileno())\n",
    "            else:\n",
    "                is_new = False\n",
    "\n",
    "        s = self.get_simple_socket()\n",
    "        if s is None:\n",
    "            return\n",
    "\n",
    "        if self.use_ssl:\n",
    "            try:\n",
    "                context = self.get_ssl_context(cert_reqs=ssl.CERT_REQUIRED,\n",
    "                                               ca_certs=(temporary_path if is_new else cert_path))\n",
    "                s = context.wrap_socket(s, do_handshake_on_connect=True)\n",
    "            except socket.timeout:\n",
    "                self.print_error('timeout')\n",
    "                return\n",
    "            except ssl.SSLError as e:\n",
    "                self.print_error(\"SSL error:\", e)\n",
    "                if e.errno != 1:\n",
    "                    return\n",
    "                if is_new:\n",
    "                    rej = cert_path + '.rej'\n",
    "                    if os.path.exists(rej):\n",
    "                        os.unlink(rej)\n",
    "                    os.rename(temporary_path, rej)\n",
    "                else:\n",
    "                    util.assert_datadir_available(self.config_path)\n",
    "                    with open(cert_path, encoding='utf-8') as f:\n",
    "                        cert = f.read()\n",
    "                    try:\n",
    "                        b = pem.dePem(cert, 'CERTIFICATE')\n",
    "                        x = x509.X509(b)\n",
    "                    except:\n",
    "                        traceback.print_exc(file=sys.stderr)\n",
    "                        self.print_error(\"wrong certificate\")\n",
    "                        return\n",
    "                    try:\n",
    "                        x.check_date()\n",
    "                    except:\n",
    "                        self.print_error(\"certificate has expired:\", cert_path)\n",
    "                        os.unlink(cert_path)\n",
    "                        return\n",
    "                    self.print_error(\"wrong certificate\")\n",
    "                if e.errno == 104:\n",
    "                    return\n",
    "                return\n",
    "            except BaseException as e:\n",
    "                self.print_error(e)\n",
    "                traceback.print_exc(file=sys.stderr)\n",
    "                return\n",
    "\n",
    "            if is_new:\n",
    "                self.print_error(\"saving certificate\")\n",
    "                os.rename(temporary_path, cert_path)\n",
    "\n",
    "        return s\n",
    "    \n",
    "    def send_requests(self):\n",
    "        '''Sends queued requests.  Returns False on failure.'''\n",
    "        self.last_send = time.time()\n",
    "        make_dict = lambda m, p, i: {'method': m, 'params': p, 'id': i}\n",
    "        n = self.num_requests()\n",
    "        wire_requests = self.unsent_requests[0:n]\n",
    "        try:\n",
    "            self.pipe.send_all([make_dict(*r) for r in wire_requests])\n",
    "        except BaseException as e:\n",
    "            self.print_error(\"pipe send error:\", e)\n",
    "            return False\n",
    "        self.unsent_requests = self.unsent_requests[n:]\n",
    "        for request in wire_requests:\n",
    "            if self.debug:\n",
    "                self.print_error(\"-->\", request)\n",
    "            self.unanswered_requests[request[2]] = request\n",
    "        return True\n",
    "\n",
    "def check_cert(host, cert):\n",
    "    try:\n",
    "        b = pem.dePem(cert, 'CERTIFICATE')\n",
    "        x = x509.X509(b)\n",
    "    except:\n",
    "        traceback.print_exc(file=sys.stdout)\n",
    "        return\n",
    "\n",
    "    try:\n",
    "        x.check_date()\n",
    "        expired = False\n",
    "    except:\n",
    "        expired = True\n",
    "\n",
    "    m = \"host: %s\\n\"%host\n",
    "    m += \"has_expired: %s\\n\"% expired\n",
    "    util.print_msg(m)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    client=TcpConnection('/home/john/myapi')\n",
    "    interface=client.get_socket()\n",
    "    #while(interface is None):\n",
    "    #    interface=client.get_socket()        \n",
    "        \n",
    "    socketPipe=SocketPipe(interface)\n",
    "    \n",
    "    #params = [ELECTRUM_VERSION, PROTOCOL_VERSION]\n",
    "    #id=0\n",
    "    #socketPipe.addMsg('server.version', params, id)\n",
    "    #socketPipe.send_requests()\n",
    "    #socketPipe.get()\n",
    "\n",
    "    params = [10,15]\n",
    "    id=0\n",
    "    socketPipe.addMsg('blockchain.block.headers', params, id)\n",
    "    socketPipe.send_requests()\n",
    "    print(socketPipe.get())\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{'jsonrpc': '2.0', 'result': {'hex': '00000020d22544b570a458cd2ec9cee8ce16380d929a9ccac82dc72c11164e697b0300000731ac9376e2fffde9ff43a10861ee724b4ab7fd4840c4b5d3728e8ad00818bccd2bfe5bf0ff0f1efe9b0100000000204fbe927aa20217f7d399395a9b3c0bc98049291562338ac1b35be249d600000047e44bf660bc367c2cf30b31714ad1552843f9fca340906dc79e7df0229d9df1e42bfe5bf0ff0f1e6a9d1000000000207cb60f88e7424e1eddd17193b2b25b7628ff21ca855ed3475aa5c9f1ab0600004a831ee327d56278ef7f7313827ba89a794ccb2bc35b29b32da772714fe0650c192cfe5bf0ff0f1e2fcd2500000000203f166a30b6e1edc14ca1f9f31d075f17fc7ae2228d41513571a7e9e02007000024b48fedc0650f267196a446de57a8cc979852e4b97c2c1d7a5da7f036754a1a242cfe5bf0ff0f1e1e13080000000020009b49ebfc6230534d40c85ede4fae27fa3d1812736e90efcb5cef72b006000008a40da65c2ffda2bf6c1f6165096bd76e1fd85bea594a2510beb475647efec74a2cfe5bf0ff0f1ed64016000000002030781b90596a99cd903c451567844e068db41c69585956a8704b0c8f67070000571130f152ff4f3f0f65d7ab806ef68bfe96380081bbfa107bb29e64aa2a1b135e2cfe5bf0ff0f1ebc360e00000000200f0685488cb0cd037234f157f73b139f66386746f52c7ac496cca8f3e7040000669a438797880edc3d62227b9b0c4bc02fd6eed4d9315a3674eb87ced8878389662cfe5bf0ff0f1ec07605000000002047626f62a0582759a3ba00ee9cfad2fbbc47fa5cd323373e1462469765060000d1c93e74e9f55ef5bcce8cfbe5691937a452da63c484dd4b425a4e719cbfba40722cfe5bf0ff0f1e02ef080000000020dcc3f4bff643f0576f93c28980afea6dfff5b6af7f55886d97215c5749090000bbcb8576b88a110b9c3499b0ecd87f1cd6a7246cda68730199cb4b2330c2dc487b2cfe5bf0ff0f1e2dd1040000000020c19700c6bba834b831f8db12d9bc1ea7c0e3148ea5c29fea16c5fb37490f000006440f974a3873521ff79844cbb0ae9bd9cf0b252315f1c4ab1ff86aee718f108d2cfe5bf0ff0f1e27d80a00000000208c18ab86e96939c4984cb2ef36d475cc9f89d104b616ec260480a5ab4a0900003af3cd6c7f8309fdf04c3b43a1a3d7de30f99d194206ba2c3254631d7642d8ad942cfe5bf0ff0f1e67260400000000209d962d1fed9182d49a5567ada896d5a5ba1883be85886de7b86a53c0860c00006f834c62c0ae1b713af64b2768dc0b7dfbdbea9030948bd8597702a0ebb1815c952cfe5bf0ff0f1ecb33000000000020154b39e10efeacd63cb7115ae1316c0eb31c491eae8a74bf147207505301000096740e95553bebf4e04856a561b75507e1b587da6de037b80815d6e101692615a52cfe5bf0ff0f1e1bbe0b0000000020969e8d2f616bf36301bdb86eda9503c35731a7241d50417fc7bb32bc710f000067539cdeeda3a750cda308d10b6392336b860fd34716864a637f6e278e945c0fa62cfe5bf0ff0f1ea14700000000002077a1a86ffdfa711f6f3ec73537f0f98ac0d1b9d7c31f3c757a1ea249930f0000d52a15b6dde2af3f71f862928034a49a844c055f01cbfbc56b73ab999ec79d89b42cfe5bf0ff0f1e2a110a00', 'count': 15, 'max': 2016}, 'id': 0}\n"
     ]
    }
   ],
   "source": [
    "%run myssl.py"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{'jsonrpc': '2.0', 'result': ['ElectrumX 1.8.12', '1.2'], 'id': 0}\n"
     ]
    }
   ],
   "source": [
    "%run myssl.py server.version \"bbb\" 1.2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{'jsonrpc': '2.0', 'result': {'hex': '00000020d22544b570a458cd2ec9cee8ce16380d929a9ccac82dc72c11164e697b0300000731ac9376e2fffde9ff43a10861ee724b4ab7fd4840c4b5d3728e8ad00818bccd2bfe5bf0ff0f1efe9b0100', 'count': 1, 'max': 2016}, 'id': 0}\n"
     ]
    }
   ],
   "source": [
    "%run myssl.py blockchain.block.headers 10 1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{'jsonrpc': '2.0', 'result': ['ElectrumX 1.8.12', '1.4'], 'id': 0}\n"
     ]
    }
   ],
   "source": [
    "%run myssl.py server.version bbb 1.4"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{'jsonrpc': '2.0', 'result': 'You are connected to an ElectrumX 1.8.12 server.', 'id': 0}\n"
     ]
    }
   ],
   "source": [
    "%run myssl.py server.banner"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
